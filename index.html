<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>AirBass</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/resume.min.css" rel="stylesheet">

</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-block d-lg-none">AirBass</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/system_profile.jpg" alt="">
      </span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#high-level">High-Level Design</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#in-depth">In-Depth Breakdown</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#results">Results</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#conclusions">Conclusions</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#appendix">Appendix</a>
        </li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid p-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="about">
      <div class="w-100" style="float:left;">
        <h1 class="mb-0">Air
          <span class="text-primary">Bass</span>
        </h1>
        <div class="subheading mb-5">ECE 4760 Final Project built by:
          <ul>
            <li>Caitlin Stanton (cs968)</li>
            <li>Peter Cook (pac256)</li>
            <li>Jackson Kopitz (jsk363)</li>
          </ul>
        </div>

        <div class="mb-5">
          <h2 class="mb-5">Introduction</h2>
          <div class="resume-content mb-0">
            AirBass is an air bass guitar that allows the user
            to play distinct notes without the added weight and cost of an actual
            bass guitar. It implements various sensors for input to output sound
            that is accurate both in terms of frequency and duration.
          </div>
        </div>
      </div>
      <div class="w-100" style="float:right">
        <img class="img-fluid mx-auto mb-2" src="img/system_profile.jpg" alt="">
      </div>
    </section>

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="high-level">
      <div class="w-100">
        <h2 class="mb-5">High-Level Overview</h2>

        <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-5">Social Impact</h3>
            <p>Our plan for this project was mainly for entertainment purposes,
              and is not dangerous. Nevertheless, we constructed a user-friendly
              playable instrument that is similar to a bass guitar. As far as we
              know, this is a novel idea that we originated. We were able to
              achieve this goal by combining information discussed in previous
              labs with our own ideas.</p>

            <p>In theory, our design is relatively inclusive for all types of ability.
              This device is one that can be held like a guitar, but can also be placed
              on a table or the floor to be played, meaning that users who can’t hold
              objects for a long time and/or in an upright position can also play.
              The use of a glove fitted with flex sensors makes playing our air
              bass easier than a real guitar since the user does not need to make
              full contact with the strings and their fingertips in order to produce
              a sound. Users still need to have two functioning hands so that they
              can strum using the flex sensor glove with one and simulate fret
              positioning with the other, but this is theoretically be easier
              than literal plucking and holding down strings.</p>

            <p>Color and identifying specific shapes/patterns don’t play much of a
              role in our implementation, so those who have color blindness or poor
              eyesight should have a similar experience as those with full seeing ability.
              For full user experience, some hearing ability is needed—this
              doesn’t help with interfacing with the device itself, but improves
              the general functionality of our project as a way to practice guitar
              without physically owning one. Being able to hear the synthesized
              notes enhances the user’s chances to self-correct the placement
              of their fingers and the timing of their strumming so as to play
              songs that they choose.</p>

          <p>Our project doesn’t involve any over-air communication, so there
            are no specific IEEE or FCC standards that we must follow. Additionally,
            our use of inputs and outputs that pose little to no harm to the user
            imply that there aren’t any major ANSI, ISO, or FDA standards that are
            applicable. Copyright claims are not much of a concern to our team,
            as the user will be responsible for any melodies they create and how
            they wish to share them.</p>

        </div>
      </div>

      <div class="resume-item d-flex flex-column flex-md-row justify-content-between">
        <div class="resume-content">
        <h3 class="mb-0">Implementation Overview</h3>
        <p>The slab of wood is used to mimic the neck of a bass guitar, as shown
          in Figure 1 below. To synthesize the four individual strings, we aligned
          four beam break sensors parallel to the length of the wood. If a finger
          is placed on one of the “strings”, the line break sensor registers this
          and it narrows down the range of potential frequencies of sound that
          we’d have to output. Ultimately, nothing is played until one of the
          strings are strummed by flexing a finger in the glove - then, a
          frequency is output to the DAC with an envelope that starts and
          stops depending on the reading from the flex sensor.</p>

          <img src="img/sensor_block_diagram.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
          <p style="text-align:center"><i><b>Figure 1: Diagram of sensor placement on the
          neck of the AirBass</b></i></p>

        <p>Line break sensors can only detect if an object has passed between the pair,
          not the location of where the object broke the line. Since the positioning
          of your fingers on each string of a guitar is crucial to playing a certain
          note, we need to analyze what finger is being placed on the “string”
          and at what fret.</p>

        <p>For the latter, to determine at which fret the user is playing, we
          used an ultrasonic distance sensor. This sensor is placed at the end
          of the wood slab to measure how far down the next of the guitar the
          user’s hand is. This distance data is used to decide which fret the
          user is playing, based on the length of the neck of a guitar and the
          typical placement of each fret. This data is used in part to determine
          which frequency the user is attempting to play. Note that in our implementation,
          for simplicity we assume that the user is playing a single note at a time
          since we did not want to overcomplicate our logic.</p>

        <p>For strumming, we use a black polyester glove with short flex sensors
          attached to the inside of each finger, as shown in Figure 2. These
          sensors have a resistance of ~30KΩ when at rest and up to ~100KΩ when
          flexed. When the user bends a finger, we determine which finger is bent,
          which line break sensor has been broken, and how far down the neck the
          user’s hand is to determine which note is being played. This also serves
          as a kind of redundancy check, so that a note is played both when the
          string/line is broken and when a corresponding finger is bent.</p>

          <img src="img/glove_block_diagram.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
          <p style="text-align:center"><i><b>Figure 2: Diagram of flex sensor glove</b></i></p>

        <p>Using additive synthesis, we produce approximately bass-like sounds,
          similar to lab 1. We use the DAC, setting the output in an ISR that is
          timed to accurately sample desired notes, the audio jack, and the lab
          speakers to play the music the user requires.</p>

        </div>
      </div>
    </div>
  </section>

  <hr class="m-0">

  <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="in-depth">
    <div class="w-100">
      <h2 class="mb-5">In-Depth Breakdown</h2>

      <h3 class="mb-0">Break Beam Sensors</h3>

      <h3 class="mb-0">Ultrasonic Distance Sensor</h3>
      <p>On a guitar, the sound of the note being played changes not only based
        on the strings being plucked but also the fingers placed on the frets.</p>

      <img src="img/fretboard_photo.jpeg" alt="" style="display:block; margin-left:auto; margin-right:auto;">
      <p style="text-align:center"><i><b>Figure 3: Typical fretboard of a bass guitar, with
      strings and fret annotated</b></i></p>

      <p>To determine which of the frets were being placed, we used a
        <a href="https://www.sparkfun.com/products/15569">SparkFun SEN-15569</a>
        ultrasonic distance sensor. The general overview of this sensor is that,
        once triggered, eight 40kHz signals are sent out to potentially reflect
        off of any objects that are in front of the sensor. If a signal is
        reflected back, then the outputted signal (aka echo) is equal to the
        difference in time between the pulse and the received pulse. For this
        to be incorporated into our prototype, we wanted to use the ultrasonic
        distance sensor to detect the distance from the top of the neck of our
        bass guitar to the user’s playing hand. This result would then be used to
        determine on which fret the first finger was placed.  This sensor needed
        a 5V power supply, which we were able to provide using the MCU Vin pin.
        There was no need for a voltage regulator because we knew our final
        prototype would use the 5V power adaptor. In the case of the PIC32 being
        powered with a separate battery, a voltage regulator would be needed to
        keep the sensor powered at a steady 5V with no sharp increases in voltage
        or spikes in current.</p>

        <img src="img/distance_positioning.jpg" alt="" style="display:block; margin-left:auto; margin-right:auto;">
        <p style="text-align:center"><i><b>Figure 4: Ultrasonic distance sensor
        placed alongside beam break sensors on final prototype</b></i></p>

      <p>The implementation of this general process can be seen in the thread
        <code>protothreads_distance</code>. The trigger—which, when set,
        would start the series of pulses to read the distance to an object—was
        connected to MCU pin RPA1, which had been enabled as an output. As
        long as the <code>define use_uart_serial</code> statement was commented
        out in the <code>config_1_3_2.h</code> file, there was no other use
        for this pin, and therefore nothing preventing us from sending the
        trigger signal on it. Pin A1 was set high for one millisecond and
        then cleared. The minimum length of time that A1 needed to be set for
        was 10 microseconds, so the one millisecond delay was reasonable.</p>

      <p>The actual reading from the echo signal was done using an input capture
        on MCU pin RB13. An input capture is a hardware timer, where the time of
        specified edge of a signal received by the input capture pin is measured.
        This provides an extremely accurate timing of events, up to within a
        cycle of the signal edge occuring. We decided to use this hardware timer,
        rather than reading the signal on a digital GPIO pin and using a counter
        variable, because it wasn’t as likely to hang. If we had used the GPIO
        pin and software timing route, our logic for the protothread would’ve
        kept it stuck waiting for a pulse back, thereby preventing us from
        setting a new trigger signal.</p>

      <p>The code written to initialize the input capture can be found between
        lines 521 and 533 in <code>main()</code>. The input capture required a
        timer, as it would be used to keep track of the edge of the inputted
        signal. For our program, we used timer3 for this purpose, and initialized
        it to take continuous readings and have a prescaler value of 32. The
        prescaler prevented the results from the input capture to not overflow.
        An additional precaution for this was declaring the distance readings as
        unsigned integers.</p>

      <p>Next we configured capture1 to be connected to an interrupt service
        routine (ISR) that would read integer timer values on <code>timer3</code> due to the
        falling edge of a signal. Using an ISR prevented any other parts of the
        program from overriding the distance sensor so that we would get the most
        accurate readings from the input capture. Taking values from the falling
        edge of the signal would only provide a distance once the entirety of a
        returned pulse had been received. Lastly, MCU pin RPB13 was connected to
        <code>capture1</code> using PPS.</p>

      <p>Since the ISR would preempt any other functions that were running at
        the time, we took care to make the ISR as brief as possible to not let
        any other functions hang. This meant that the ISR only ran two lines of
        code: <code>mIC1ReadCapture()</code> to save the value off of <code>timer3</code>
        when the reflected pulse was received; and <code>mIC1ClearIntFlag()</code>
        to clear the timer interrupt flag.</p>

      <p>Within <code>protothreads_distance</code>, after the trigger signal
        was set for one millisecond, the interrupt flag for the <code>capture1</code>
        ISR was cleared and <code>timer3</code> was set to zero. The first function
        was performed so that <code>capture1</code> would be accurately updated
        with the most recent falling edge. The second call was made so that no
        additional arithmetic had to be performed to find the length of time
        between the 40kHz pulses and the reflected pulse.</p>

      <p>Once the ISR read from the input capture pin, an finite impulse
        response filter was applied to make the value more reliably accurate,
        otherwise we noticed a large amount of fluctuation. The averaging was
        done over the four most recent input capture values, which were saved
        into a circular buffer whose starting and ending indexes were constantly
        updated. The variable distance would be incremented by the difference
        between the most recent reading and the least recent reading in this
        circular buffer.</p>

      <p>When reading the echo pin from the sensor on the oscilloscope, we noted
        slight noise. The theory behind this is that it’s caused by the
        switching within the sensor itself, most likely due to the MHz clock.
        At first, we placed an electrolytic capacitor between power and ground.
        Although it did reduce noise, it has an internal frequency of around 100kHz,
        leading to slow switching rates. Ultimately, we built a low pass voltage
        divider filter, as shown below. We made sure to use a ceramic capacitor
        as it has a faster internal frequency, and therefore our circuit would
        have a faster response.</p>

        <img src="img/echo_circuit.jpg" alt="" style="display:block; margin-left:auto; margin-right:auto;">
        <p style="text-align:center"><i><b>Figure 5: Our protoboarded echo pin
        circuit</b></i></p>

      <p>Now that the distance reading was averaged, it had to be calibrated.
        After working with the distance sensor a bit, we noticed that the distance
        values changed based on the positioning of the object it was looking at.
        In the case of our prototype, this object was the side of a hand, which
        is extremely hard to maintain in a static position with the same amount
        of surface area being presented, despite the strings and/or frets it’s at.
        To remedy this, we spent a decent amount of time measuring the distance
        sensor’s output across various combinations of depressed strings and frets.
        The calibration data for this can be seen in the table below:</p>

      <table></table>
      <p style="text-align:center"><i><b>Figure 6: Table of the final calibrated values
      for the ultrasonic distance sensor, based on strings and frets</b></i></p>

      <h3 class="mb-0">Flex Sensors</h3>

      <p>In order to accurately determine when individual strings of our bass
        are “plucked,” we used the <a href="https://www.sparkfun.com/products/10264">
        SparkFun SEN-10264</a> two-inch flex sensors. At a high level, the idea
        for implementing these sensors is that we could use the variable
        resistance across the terminals in a voltage divider circuit, so that
        the output voltage could be used to determine which of four strings is
        being plucked (one string corresponding to each flex sensor). The result
        is that we can accurately pluck open strings, start and stop playing
        individual notes independent of the fret/finger position decided by
        the beam breaks and distance sensor, as would be the case in a real
        bass. To further liken the experience of our AirBass to an actual bass
        guitar, we have the flex sensors attached to the inner palm of a glove
        so that the integrated system can register moving a finger while wearing
        the glove, and begin playing the desired note. The final setup is shown below.</p>

      <img src="img/flex_sensor_setup.jpg" alt="" style="display:block; margin-left:auto; margin-right:auto;">
      <p style="text-align:center"><i><b>Figure 7: Final setup for flex sensor glove - pinky, ring, middle,
         and pointer finger control plucking of the G, D, A, E strings, respectively.</b></i></p>

      <p>To construct our voltage divider (to divide the supply Vcc = 3.3V when
        flexing the device), we first measured the resistance of the flex sensors.
         We found that they have an unflexed resistance of about 30K, which
         approximately linearly increases to about 100K when fully flexed.
         Noting these values, we decided to put the flex sensor in parallel to
         the output and chose a series resistance Re = 50K to Vcc, since this
         gives an output voltage that ranges between ~1.2V and ~2.2V, which is
         appropriate for 3.3V level logic.</p>

     <img src="img/flex_circuit_equation.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
     <p style="text-align:center"><i><b>Figure 8: Equation for the voltage divider used for reading
       a varying output voltage from our flex sensor.</b></i></p>

     <p>Next, we noticed that for our final implementation we only cared about a
       true/false value answering the question “is string i being plucked?” for
       each of the four strings i. Accordingly, we tried a few circuits to convert
       this analog output voltage (ranging ~1.2V to ~2.2V) to a digital high or
       low signal. Initially, we attempted to use the voltage divider output for
       triggering an open drain FET (i.e. with the source grounded and the gate
       this voltage divider output), since then we could easily pull the output
       voltage up to the MCU’s power rail. We abandoned this approach for two
       reasons: (1) the FET took relatively long to trigger and we saw an approximately
       exponential rise time on the oscilloscope, which is no-nideal here since
       we need a fast response to play the bass realistically, and (2) to avoid
       any mechanical effects of the sensor and make it “easier” to pluck the
       strings, we decided we needed some hysteresis in our trigger circuit so
       that a user would have to intentionally unflex a finger to stop plucking
       the string rather than this kind of event happening accidentally. Hence,
       we used a Schmitt trigger.</p>

    <img src="img/schmitt_circuit_equation.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
    <p style="text-align:center"><i><b>Figure 9: Equation for the Schmitt trigger,
      specifically with resistance values R1 = 12K, R2 = 15K, R3 = 30K, RE = 50K.</b></i></p>

    <p>As shown in Figure 8 and in the circuit schematic in Appendix C, the
      output of our voltage divider is the input voltage
      for an inverting Schmitt trigger, on the inverting terminal of the amplifier.
      The resulting circuit, with resistance values as stated above, has a high
      threshold of 2.1V and a low threshold of 1.5V. That is, when the output is
      currently low (sitting at 0V) and the input (V-) to the inverting terminal
      goes above 1.5V, the circuit triggers and brings the output to 3.3V. When
      the output is currently high and the input goes below 2.1V, the circuit
      triggers and brings the output to 0V. Since our voltage divider ranges over
      values ~1.2V to ~2.2V, these thresholds are within our capabilities and we
      effectively have an integrated circuit whose output will be digital high
      when the sensor is flexed and low when it is not flexed (with some hysteresis).
      For our final design, we have four of this circuit (one for each string/flex
      sensor) and in practice, we saw that while this did work reasonably well,
      for some of the sensors unflexing to go back below the high threshold was a
      little difficult. Not all of the sensors have the same range of resistances,
      and for one sensor in particular it was difficult to make the digital high
      output go low again, while it worked like a charm for the others.</p>

    <img src="img/flex_sensor_protoboard.jpg" alt="" style="display:block; margin-left:auto; margin-right:auto;">
    <p style="text-align:center"><i><b>Figure 8: Completed circuit used in demo, with four duplicated Schmitt
      triggers near the top of the image.</b></i></p>

      <h3 class="mb-0">Final Integration</h3>
      <p>All of the aforementioned sensors had their inputs and outputs combined
        to produce a series of synthetic bass notes based on the user. Each thread
        for the sensor set variables that were used to properly determine the
        frequency of this sound, as well as when it occurred and for how long.</p>

      <p>Within <code>main()</code>,<code>timer2</code> was configured to interrupt
        909 times a second (equal to 40MHz divided by our hardcoded sampling frequency,
        44kHz). To make sure the big board would be outputting to the DAC pins, the
        chip select was also set by making MCU pin RB4 an output. Then sine lookup
        table was calculated. To do this, we first created a table of regular sine
        values <code>sine_table</code>, to cover a complete cycle of a sine wave
        with <code>sine_table_size</code> datapoints, and then created a new table
        <code>sine_table_harmonix</code> also covering a complete cycle, adding
        five harmonics with hardcoded weights to the original wave to produce a
        more string-like sound. We found these weights on the DAC page of the
        ECE 4760 website. Each value of sine_table_harmonix was then scaled to
        be within the inclusive range of [-1,1], much like the original sine table
        created earlier in the function. Lastly, the phase increment array
        <code>ph_incr</code> was filled with frequency values that matched the
        specific string/fret combinations of a bass guitar—this array contained
        23 values, as each string had an open frequency and six frets, and each
        string was separated by fifth (such that playing the fifth fret on a
        string would produce a sound equivalent to the next open string).</p>

      <p>The DAC ISR, connected to <code>timer2</code>, was the final piece of
        the puzzle. First it cleared the <code>timer2</code> interrupt flag.
        Once that was done, conditional logic was used to determine the frequency,
        from <code>ph_incr</code> and <code>sine_table_harmonix</code>, that would
        be output to the DAC. First, it had to be seen if at least of the strings
        had been “plucked”, as determined by the flex sensor glove.</p>

      <p>The flex sensor outputs were read using MCU pins Z4,Z5,Z6,Z7 on the port
        expander. In an SPI critical section we read the current Z port into a local
        variable and outside this critical section checked individual bits of the
        word to determine which flex sensors were flexed and which were not. We
        set integers <code>e_pluck</code>, <code>a_pluck</code>, <code>d_pluck</code>,
        <code>g_pluck</code> to 0 or -1 depending on which bits of the word were
        high to indicate whether or not a sensor was being flexed.</p>

      <p>If a string had been plucked, the phase variable for that specific string
        (<code>e_phase</code>, <code>a_phase</code>, <code>d_phase</code>, <code>g_phase</code>)
        was incremented. The value to increment each phase variable by was at
        index 5i*i_fret within <code>ph_incr</code>, where the i in 5i corresponds
        to each string represented as an integer (E = 0; A = 1; D = 2; and G = 3)
        and the i in i_fret corresponds to each string (E, A, D, G). The reason
        for the former definition of i is to nail down the fact that the strings
        are separated by fourths within <code>ph_incr</code>, and therefore the
        next open string frequency can be found at every fifth element of the table. The
        latter definition stems from the readings from the ultrasonic distance sensor.</p>

      <p>The distance ranges from the ultrasonic distance sensor were used in a
        series of conditional statements to set the fret for each individual string
        being depressed: <code>e_fret</code>, <code>a_fret</code>, <code>d_fret</code>,
        and <code>g_fret</code>. If none of the four strings were depressed (meaning
        that zero of them had their beam break broken), then all four fret variables
        were set to zero, indicating an open string. If at least one of the four
        strings were being depressed, then the fret variables were set if 1) that
        specific string was depressed and 2) the distance sensor reading was within
        the range for that fret. Since the farther frets would have larger distance
        readings, those ranges were used in earlier if statements. The reasoning
        behind this was that it was that a higher distance range was easier to a
        chieve, and so by putting these ranges earlier, it ensured that lower
        distance readings wouldn’t accidentally be set to the wrong fret. For
        example, on the E string, the first fret was expecting a distance reading
        of less than 120—if the logic for setting the first fret came before the
        logic for setting the second fret, then the second fret would be the final
        (yet wrong) result.</p>

      <p>Cascading ranges (which checked to see if distance was less than the calibration
        value) were used rather than constricted ranges (which checked to see if
        distance was both greater than a calibration value and less than another
        calibration value). This was because of the variation between the boundaries
        of each fret. We felt that using cascading ranges would cut down on the amount
        of accidental fret switching due to the ultrasonic distance sensor not being
        as precise as possible.</p>

      <p>The variable <code>sum_strings</code> was used to store the sine values
        from <code>sine_table_harmonix</code>. Similar to the logic to find the
        phase variable for each string, if a string had been plucked, <code>sum_strings</code>
        was set to the value in <code>sine_table_harmonix</code> indexed at the
        string’s phase variable (which had been shifted by 24 to prevent the
        index from going out of bounds of the table).</p>

      <p>Now that the frequency of the sound had been set, it was time to set the
        amplitude envelope of the sound wave itself. This was also based on the
        flex sensor glove output. Boolean state variables <code>string_depressed</code> and
        <code>prev_string_depressed</code> indicated whether or not one of the four
        strings is currently being plucked or was being plucked in the previous
        read to the Z port. If we transitioned from nothing plucked to some string
        being plucked, we started timing a new note/amplitude envelope by setting
        <code>current_amplitude</code> to 0 and <code>curr_attack_time</code> to
        0 as well. Similarly, if we transition from something plucked to nothing
        being plucked, we set <code>current_amplitude</code> to <code>max_amplitude</code>
        and <code>curr_decay_time</code> to 0.</p>

      <p>In the audio ISR, even more conditional logic is used around <code>string_depressed</code>
         and <code>prev_string_depressed</code>. If at least one string was
         depressed and <code>curr_attack_time</code> had not reached its maximum,
         this meant that the sine wave hadn’t reached its maximum amplitude, and
         therefore <code>curr_attack_time</code> and <code>current_amplitude</code>
         were increased accordingly. Otherwise, if the <code>curr_attack_time</code>
         was at maximum value, the <code>current_amplitude</code> was set to
         <code>max_amplitude</code> for redundancy. If no strings were depressed and
         <code>curr_decay_time</code> had not reached its maximum, this meant that
         the sine wave hadn’t reached its minimum amplitude, and therefore
         <code>curr_decay_time</code> was incremented and <code>current_amplitude</code>
         decremented. Otherwise, if the <code>curr_decay_time</code> was at maximum
         value, <code>current_amplitude</code> was set to 0 (the minimum sine wave
         amplitude) for redundancy. The attack portion of the sine wave increased
         linearly, while the decay part of the sine wave decreased linearly. The
         result of this logic gives the ability to play sustained notes with the
         attack and decay part of the envelope so that it sounds less harsh and
         ideally more like an actual bass.</p>

      <p>The final result of AirBass was sent to MCU pin DAC_A, which was the sum of
        2048 and the product of <code>current_amplitude</code> and <code>sum_strings</code>.
        Since <code>sine_table_harmonix</code> is between the range of -1 and 1, so
        is <code>sum_strings</code>. Multiplying this variable by <code>current_amplitude</code>
        moves it to the range -208 to 2048. Adding 2048 further modifies this range
        to 0 to 4096 so that the DAC can properly receive the sine wave.
        This was then written to SPI to actual produce the sound, after which
        the SPI was free to be used by either the port expander or the DAC.
        To prevent any unwanted collisions on the combined use of SPI from the DAC
        and the port expander, we made sure to use SPI critical sections wherever
        needed and to limit the amount of code within them, so as to not take too
        much time.</p>

      <p>An audio jack was soldered from the output of DAC_A to be plugged into
        a speaker so the user could hear the produced sound. There was minimal
        crackling, so we added a low pass filter between DAC_A and the audio
        jack to keep the sound as smooth and steady as played by the user.</p>


    </div>
  </section>

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="results">
      <div class="w-100">
        <h2 class="mb-5">Results</h2>
        <iframe style="display:block; margin-left:auto; margin-right:auto;" width="560" height="315" src="https://www.youtube.com/embed/XHtV47E0zYU" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        <p style="text-align:center"><i><b>Our final demo!</b></i></p>

        </div>
    </section>

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="conclusions">
      <div class="w-100">
        <h2 class="mb-5">Conclusions</h2>

        <h3 class="mb-0">Ultrasonic Distance Sensor</h3>
        <p>Although the distance sensor did perform as wanted, the calibration of the
        sensor could’ve been improved. The majority of our work with the sensor was
        finding the distance values at each fret and changing those values as we
        recognized the natural way a user would hold our prototype. As mentioned
        earlier, the human hand isn’t a flat, regular surface, so even tilting the
        playing hand slightly would affect the distance reading. Although we tried
        to alleviate this by extending the distance ranges for each fret, our final
        prototype did experience slight toggling between note frequency when fingers
        were placed on the boundary between two frets. A fix for this would’ve been
        adding multiple distance sensors, perhaps one for each string (to accommodate
        for the different readings at each string position) or a single one at the
        other end of the neck of the guitar (for calibrating against the difference
        of the two recorded values).</p>
        </div>
    </section>

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="appendix">
      <div class="w-100">
        <h2 class="mb-5">Appendix</h2>

        <h3 class="mb-5">Appendix A</h3>
        <p>The group approves this report for inclusion on the course website.</p>
        <p>The group approves the video for inclusion on the course youtube channel.</p>

        <h3 class="mb-5">Appendix B</h3>
        <script src="https://gist.github.com/caitlinstanton/bf1b71b87299e339299923079db807ba.js"></script>

        <h3 class="mb-5">Appendix C</h3>
        <img src="img/distance_circuit.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
        <p style="text-align:center"><i><b>Figure XXX: Low pass voltage divider on the
        echo pin of the ultrasonic distance sensor</b></i></p>

        <img src="img/flex_circuit.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
        <p style="text-align:center"><i><b>Figure XXX: Voltage divider used for
          reading a varying output voltage from our flex sensor.</b></i></p>

        <img src="img/schmitt_circuit.png" alt="" style="display:block; margin-left:auto; margin-right:auto;">
        <p style="text-align:center"><i><b>Figure XXX: Full flex sensor, with MCP6242 amplifier, and resistance
          values R1 = 12K, R2 = 15K, R3 = 30K, RE = 50K.</b></i></p>

        <h3 class="mb-5">Appendix D</h3>
        <table style="border: 1px solid black;">
          <tr style="border: 1px solid black;">
            <th style="border: 1px solid black;">Part Name</th>
            <th style="border: 1px solid black;">Vendor</th>
            <th style="border: 1px solid black;">Part Number</th>
            <th style="border: 1px solid black;">Unit Price</th>
            <th style="border: 1px solid black;">Quantity</th>
            <th style="border: 1px solid black;">Total</th>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">IR Beam Break Sensor</td>
            <td style="border: 1px solid black;">Adafruit</td>
            <td style="border: 1px solid black;">A2167</td>
            <td style="border: 1px solid black;">$1.95</td>
            <td style="border: 1px solid black;">4</td>
            <td style="border: 1px solid black;">$7.80</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Flex Sensor 2.2"</td>
            <td style="border: 1px solid black;">SparkFun</td>
            <td style="border: 1px solid black;">SEN-10264</td>
            <td style="border: 1px solid black;">$8.95</td>
            <td style="border: 1px solid black;">4</td>
            <td style="border: 1px solid black;">$35.80</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Ultrasonic Distance Sensor</td>
            <td style="border: 1px solid black;">SparkFun</td>
            <td style="border: 1px solid black;">SEN-15569</td>
            <td style="border: 1px solid black;">$3.95</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$3.95</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Amplifier</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;">MCP6242</td>
            <td style="border: 1px solid black;">$0.36</td>
            <td style="border: 1px solid black;">2</td>
            <td style="border: 1px solid black;">$0.72</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Audio Jack</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$0.95</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$0.95</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Big Board</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$10.00</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$10.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Large Solder Board</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$2.50</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$2.50</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Small Solder Board</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$1.00</td>
            <td style="border: 1px solid black;">2</td>
            <td style="border: 1px solid black;">$2.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">MCU</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;">PIC32MX250F128B</td>
            <td style="border: 1px solid black;">$5.00</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$5.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">I/O Expander</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$5.00</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$5.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Lab Speakers</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$2.00</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$2.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Jumper Cables</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$0.10</td>
            <td style="border: 1px solid black;">50</td>
            <td style="border: 1px solid black;">$5.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">SIP Header/Socket</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$0.05</td>
            <td style="border: 1px solid black;">18</td>
            <td style="border: 1px solid black;">$0.90</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Board Power Supply</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$5.00</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$5.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Resistors/Capacitors</td>
            <td style="border: 1px solid black;">ECE Dept.</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$5.00</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$5.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Wood Plank</td>
            <td style="border: 1px solid black;">Lowe's</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$3.50</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$3.50</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Glove</td>
            <td style="border: 1px solid black;">Lowe's</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$2.00</td>
            <td style="border: 1px solid black;">2</td>
            <td style="border: 1px solid black;">$4.00</td>
          </tr>
          <tr style="border: 1px solid black;">
            <td style="border: 1px solid black;">Corner Joint</td>
            <td style="border: 1px solid black;">Lowe's</td>
            <td style="border: 1px solid black;"></td>
            <td style="border: 1px solid black;">$0.75</td>
            <td style="border: 1px solid black;">1</td>
            <td style="border: 1px solid black;">$0.75</td>
          </tr>
          <tr style="font-weight:bold;border: 1px solid black;">
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td style="border: 1px solid black;">Project Total</td>
            <td style="border: 1px solid black;">$99.87</td>
          </tr>
        </table>

        <h3 class="mb-5">Appendix E</h3>

        <h3 class="mb-5">References</h3>
        <ul>
          <li>Schmitt Trigger References
            <ul>
              <li><a href="https://en.wikipedia.org/wiki/Schmitt_trigger">Theory</a></li>
              <li><a href="https://www.random-science-tools.com/electronics/inverting-schmitt-trigger-calculator.htm">Circuit calculator</a></li>
            </ul>
          </li>
          <li><a href="https://cdn.sparkfun.com/datasheets/Sensors/ForceFlex/FLEX%20SENSOR%20DATA%20SHEET%202014.pdf">Flex Sensor Datasheet</a></li>
          <li><a href="http://ww1.microchip.com/downloads/en/devicedoc/21882d.pdf">Amplifier Datasheet</a></li>
          <li>Ultrasonic Distance Sensor References
            <ul>
              <li><a href="https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf">Datasheet</a></li>
              <li><a href="https://www.instructables.com/id/Simple-Arduino-and-HC-SR04-Example/">Code example</a></li>
            </ul>
          </li>
          <li><a href="https://www.adafruit.com/product/2167">Beam Break Datasheet</a></li>
          <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/index_Timers.html">Timers & Input Capture</a></li>
          <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/Math/avrDSP.htm">Additive Synthesis</a></li>
          <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32_details.html">Big Board I/O</a></li>
          <li><a href="http://people.ece.cornell.edu/land/courses/ece4760/PIC32/target_board.html">Development Board, SPI & DAC</a></li>
        </ul>
        </div>
    </section>

  </div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/resume.min.js"></script>

</body>

</html>
